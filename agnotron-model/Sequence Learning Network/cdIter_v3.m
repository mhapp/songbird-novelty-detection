function [cdNet_new] = cdIter_v2(cdNet_old, ts_idx)cdNet_new = cdNet_old;% if ts_idx >= 60%     disp('')% end% get inputif ts_idx > 1    thisInput = cdNet_old.input(:, ts_idx-1); % this -1 is a REVOLUTION!else    thisInput = zeros(size(cdNet_old.input(:,ts_idx)));end% resolve activityext_FF = cdNet_old.w_PD_CD * thisInput;rec_FF = cdNet_old.w_CD_CD * cdNet_old.old_cd;randIn = double(rand(size(cdNet_old.old_cd)) > (1-cdNet_old.pin)); %some small random activ % randIn(1:(cdNet_old.nSeed*2)) = 0; % seed neurons can't be randomly activatedy = cdNet_old.old_y + 1/cdNet_old.tau*(-cdNet_old.old_y + cdNet_old.old_cd);Aadapt = cdNet_old.alpha * y;inhib_FF = cdNet_old.beta * sum(cdNet_old.old_cd);extIn = ext_FF + randIn;netCD = extIn + rec_FF - inhib_FF - Aadapt;cdNet_new.totalVMat(:, ts_idx) = netCD;% if ts_idx == 4%     disp('')%     figure; plot(netCD);% end%rectifynetCD_X = netCD;netCD(netCD<0) = 0;% recurrent inhibinhib_Rec = cdNet_old.gamma * sum(netCD);% binarize activitythisCDAct = double(netCD - inhib_Rec > 0);thisCD_V = netCD_X - inhib_Rec;cdNet_new.totalActMat(:, ts_idx) = thisCDAct;cdNet_new.old_y = y;cdNet_new.totalVMat(:, ts_idx) = thisCD_V;cdNet_new.old_v = thisCD_V;