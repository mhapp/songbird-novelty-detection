function [cdNet_new, mmNet_new] = updateWs_v2(cdNet_old, mmNet_old, ts_idx)%%%%% actually, i think that we could split this and fold the cd and mm%%%%% parts into those respective update functions...cdNet = cdNet_old;mmNet = mmNet_old;thisV = cdNet.totalVMat(:, ts_idx);if ts_idx == 1    old_V = zeros(size(thisV));else    old_V = cdNet.totalVMat(:, ts_idx-1);end% get cd and mm activitythisCD = cdNet.totalActMat(:, ts_idx);thisMM = mmNet.totalMMMat(:, ts_idx); %this corresponds to V (un-rectified)old_cd = cdNet.old_cd;% get eta'seta_cd = cdNet.eta_cd;eta_mm = mmNet.eta_mm;%%% internal cdNet weights% stdp from fiete et al 2010thisV(thisV<0) = 0;old_V(old_V<0) = 0;dw_cdcd_s = eta_cd .* (thisCD*old_cd' - old_cd*thisCD'); dw_cdcd_v = eta_cd .* ((thisV*old_cd') - (old_V*thisCD'));% (oldV * cd% start with some linear combo of learning rules - wtf - not actually used% (either vCoef or fCoef is set to 0)dw_cdcd = cdNet.vCoef .* (dw_cdcd_v) + cdNet.fCoef .* (dw_cdcd_s);% heterosynaptic penaltydw_hLTDpre = ...    eta_cd*ones(cdNet.nCD,1)*max(0, sum(cdNet.w_CD_CD+dw_cdcd,1)-cdNet.Wmax);  % Weights leaving    %  cells (pre)    dw_hLTDpost = ...    eta_cd*max(0, sum(cdNet.w_CD_CD+dw_cdcd,2)-cdNet.Wmax)*ones(1,cdNet.nCD);  % Weights onto    % mismatch weight changedw_cdmn = -1*eta_mm .* (thisCD * thisMM')'; %weight change always opposes direction of mismatch, ignoring syn signs%%% actually change weightsif eta_cd > 0    dw_cdcd_total = dw_cdcd - cdNet.epsilon*(dw_hLTDpre+dw_hLTDpost);    w_CD_CD = cdNet.w_CD_CD + dw_cdcd_total;    w_CD_CD(w_CD_CD > cdNet.max_wCD) = cdNet.max_wCD;    w_CD_CD(w_CD_CD < 0) = 0; % cd nets not negative        w_CD_CD = w_CD_CD .* (~eye(cdNet.nCD));else    w_CD_CD = cdNet.w_CD_CD;endcdNet.w_CD_CD = w_CD_CD;mmNet.w_CD_MN = mmNet.w_CD_MN + dw_cdmn;cdNet_new = cdNet;mmNet_new = mmNet;    cdNet_new.old_cd = thisCD;